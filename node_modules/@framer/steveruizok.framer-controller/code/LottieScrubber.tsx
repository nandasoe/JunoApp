import * as React from "react"
import { PropertyControls, ControlType } from "framer"
import * as lottie from "lottie-web"

interface Props {
	markerId: string
	progress: number
	animation?: string
}

interface State {
	progress: number
	path: string
	animation?: AnimationItem
}

export class LottieScrubber extends React.Component<Props> {
	ref: React.RefObject<HTMLDivElement> = React.createRef()

	state: State = {
		progress: this.props.progress,
		path: undefined,
		animation: undefined,
	}

	componentDidMount() {
		const { animation: path } = this.props
		if (!path || !path.includes(".json")) return
		this.loadAnimation(path)
	}

	loadAnimation = (path: string) => {
		const { animation: animationInState } = this.state
		const { current: wrapper } = this.ref

		if (animationInState) {
			animationInState.destroy()
		}

		const animation = lottie.loadAnimation({
			wrapper,
			path,
			animType: "svg",
			loop: false,
			autoplay: false,
		})

		this.setState({ path, animation }, () => {
			const { progress } = this.props
			this.setAnimationProgress(progress)
		})
	}

	componentWillReceiveProps(props: Props) {
		const { progress: nextProgress, animation: nextPath } = props
		const {
			progress: progressInState,
			animation: animationInState,
			path: pathInState,
		} = this.state

		const hasPath = nextPath && nextPath.includes(".json")

		if (!hasPath && animationInState) {
			// If we've cleared the animation prop
			this.unloadAnimation()
		} else {
			if (hasPath && nextPath !== pathInState) {
				// If we've sent in a new animation props
				if (animationInState) {
					animationInState.destroy()
				}

				// Load the new animation
				this.loadAnimation(props.animation)
			} else if (animationInState && nextProgress !== progressInState) {
				// If we've sent in a new progress props
				this.setAnimationProgress(nextProgress)
			}
		}
	}

	unloadAnimation = () => {
		this.state.animation.destroy()
		this.setState({
			animation: null,
		})
	}

	setAnimationProgress = progress => {
		progress = Math.min(0.999, Math.max(progress, 0))
		const { animation } = this.state
		const frame = animation.totalFrames * progress
		animation.goToAndStop(frame, true)
	}

	render() {
		const { markerId } = this.props
		const { animation } = this.state

		return (
			<div style={{ width: "100%", height: "100%" }} ref={this.ref}>
				{!animation && <DefaultView markerId={markerId} />}
			</div>
		)
	}

	static defaultProps: Props = {
		markerId: "Marker",
		progress: 0,
		animation: null,
	}

	static propertyControls: PropertyControls<Props> = {
		markerId: { type: ControlType.String, title: "Marker Id" },
		progress: {
			type: ControlType.Number,
			title: "Progress",
			min: 0,
			max: 0.999,
			step: 0.001,
			defaultValue: 0,
		},
		animation: {
			type: ControlType.File,
			allowedFileTypes: ["json"],
			title: "Animation",
		},
	}
}

// Define some standard CSS for your component
const style: React.CSSProperties = {
	height: "100%",
	display: "flex",
	flexDirection: "column",
	justifyContent: "center",
	color: "#8855FF",
	background: "rgba(136, 85, 255, 0.1)",
	overflow: "hidden",
	fontSize: 8,
}

export const DefaultView: React.SFC<{ markerId: string }> = ({ markerId }) => {
	return (
		<div style={style}>
			<Title heading="markerId" value={markerId} />
			<div
				style={{
					display: "flex",
					flexDirection: "column",
					paddingBottom: 8,
					maxWidth: 160,
					width: "100%",
					margin: "0 auto",
				}}
			>
				<p>
					This component shows how an animation may be "scrubbed" by using some
					other value, such as those generated by a ScrollController.
				</p>
				<p>
					To use with ScrollController, add a Lottie animation file to this
					component using the Animation property control. (See{" "}
					<a href="https://www.lottiefiles.com">here</a> for example files).
					Next, create a Scroll component, connect it to a content Frame, and
					control it in an overrides file using <b>ScrollController</b> from the{" "}
					<b>framer-controller</b> library. In the same file, Override this
					component's <b>progress</b> prop with either the controller's progress
					value, or the progress value of this or any other one of its markers.
				</p>
				<p>
					See the{" "}
					<a href="https://framer-controller.netlify.com">
						framer-controller docs
					</a>{" "}
					for more info and examples.
				</p>
			</div>
		</div>
	)
}

const Title: React.SFC<{ heading: string; value: string }> = ({
	heading,
	value,
}) => {
	return (
		<div
			style={{
				display: "flex",
				flexDirection: "row",
				justifyContent: "space-between",
				paddingBottom: 8,
				maxWidth: 96,
				width: "100%",
				margin: "0 auto",
			}}
		>
			<span>
				<b>{heading}</b>
			</span>
			<span style={{ textAlign: "right" }}>{value}</span>
		</div>
	)
}

interface AnimationItem {
	totalFrames: number

	play()

	stop()

	pause()

	// one param speed (1 is normal speed)
	setSpeed(speed: number)

	// one param direction (1 is normal direction)
	setDirection(direction: number)

	// If false, it will respect the original AE fps. If true, it will update as much as possible. (true by default)
	setSubframe(flag: boolean)

	// first param is a numeric value. second param is a boolean that defines time or frames for first param
	goToAndPlay(value: number, isFrame: boolean)

	// first param is a numeric value. second param is a boolean that defines time or frames for first param
	goToAndStop(value: number, isFrame: boolean)

	// first param is a single array or multiple arrays of two values each(fromFrame,toFrame), second param is a boolean for forcing the new segment right away
	playSegments(segments: number[] | number[][], forceFlag: boolean)

	// To destroy and release resources.
	destroy()
}
